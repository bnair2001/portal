'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAuthIsReady = exports.authIsReady = exports.getLoginMethodAndParams = undefined;

var _lodash = require('lodash');

var _constants = require('../constants');

var createAuthProvider = function createAuthProvider(firebase, providerName, scopes) {
  var provider = new firebase.auth[(0, _lodash.capitalize)(providerName) + 'AuthProvider']();

  var customAuthParameters = firebase._.config.customAuthParameters;

  if (customAuthParameters && customAuthParameters[providerName]) {
    provider.setCustomParameters(customAuthParameters[providerName]);
  }

  if (providerName.toLowerCase() === 'twitter' || !(0, _lodash.isFunction)(provider.addScope)) {
    return provider;
  }

  provider.addScope('email');

  if (scopes) {
    if ((0, _lodash.isArray)(scopes)) {
      scopes.forEach(function (scope) {
        provider.addScope(scope);
      });
    }
    if ((0, _lodash.isString)(scopes)) {
      provider.addScope(scopes);
    }
  }

  return provider;
};

var getLoginMethodAndParams = exports.getLoginMethodAndParams = function getLoginMethodAndParams(firebase, credentials) {
  var email = credentials.email,
      password = credentials.password,
      provider = credentials.provider,
      type = credentials.type,
      token = credentials.token,
      scopes = credentials.scopes,
      credential = credentials.credential;


  if (credential) {
    return { method: 'signInWithCredential', params: [credential] };
  }
  if (provider) {
    if (_constants.supportedAuthProviders.indexOf(provider.toLowerCase()) === -1) {
      throw new Error(provider + ' is not a valid Auth Provider');
    }
    if (token) {
      throw new Error('provider with token no longer supported, use credential parameter instead');
    }
    var authProvider = createAuthProvider(firebase, provider, scopes);
    if (type === 'popup') {
      return { method: 'signInWithPopup', params: [authProvider] };
    }
    return { method: 'signInWithRedirect', params: [authProvider] };
  }
  if (token) {
    return { method: 'signInWithCustomToken', params: [token] };
  }
  return { method: 'signInWithEmailAndPassword', params: [email, password] };
};

var isAuthReady = function isAuthReady(store, stateName) {
  var state = store.getState();
  var firebaseState = stateName ? state[stateName] : state;
  var firebaseAuthState = firebaseState && firebaseState.auth;
  if (!firebaseAuthState) {
    throw new Error('The Firebase auth state could not be found in the store under the attribute \'' + (stateName || '') + '.auth\'. Make sure your redux-firestore reducer is correctly set in the store');
  }
  return firebaseState.auth.isLoaded;
};

var authIsReady = exports.authIsReady = function authIsReady(store) {
  var stateName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'firestore';
  return new Promise(function (resolve) {
    if (isAuthReady(store, stateName)) {
      resolve();
    } else {
      var unsubscribe = store.subscribe(function () {
        if (isAuthReady(store, stateName)) {
          unsubscribe();
          resolve();
        }
      });
    }
  });
};

var createAuthIsReady = exports.createAuthIsReady = function createAuthIsReady(store, config) {
  return (0, _lodash.isFunction)(config.authIsReady) ? config.authIsReady(store, config) : authIsReady(store, config.stateName);
};